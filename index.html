<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>è–èª•å…‰åŠ (Ace English x ç¿Šè¯æ•™è‚²)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #0b1e10;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    cursor: none; /* éš±è—æ»‘é¼  */
    touch-action: none; /* ç¦æ­¢æ‰‹æ©Ÿæ²å‹• */
  }

  /* UI å±¤ */
  #ui-layer {
    position: absolute; top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 20;
  }

  /* é€šç”¨å±…ä¸­å®¹å™¨ */
  .center-overlay {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    pointer-events: auto; /* å…è¨±é»æ“Š */
  }

  /* é–‹å§‹é¢æ¿ */
  #start-panel {
    background: linear-gradient(135deg, #c0392b, #8e44ad);
    padding: 5vmin; 
    border-radius: 20px;
    text-align: center; color: white;
    border: 4px solid #f1c40f; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    width: 85%; max-width: 400px;
    transition: opacity 0.3s;
  }

  /* å‹åˆ©é¢æ¿ */
  #victory-panel {
    display: none; /* é è¨­éš±è— */
    background: rgba(0, 0, 0, 0.9);
    padding: 5vmin;
    border-radius: 20px;
    text-align: center; color: #ffd700;
    border: 4px solid #ffd700;
    box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
    width: 90%; max-width: 600px;
  }

  h1 { margin: 0 0 10px 0; font-size: 8vmin; text-shadow: 2px 2px 0px #000; }
  p { font-size: 4vmin; margin-bottom: 20px; line-height: 1.5; color: white; }
  
  .victory-text {
    font-size: 6vmin; font-weight: bold; margin-bottom: 30px;
    text-shadow: 0 0 10px #ff0000; line-height: 1.4;
  }

  /* æŒ‰éˆ•æ¨£å¼ */
  button {
    padding: 12px 30px;
    font-size: 5vmin; 
    background: #27ae60; 
    color: white; 
    border: 3px solid #f1c40f; 
    border-radius: 50px;
    cursor: pointer; 
    font-weight: bold;
    box-shadow: 0 5px 0 #1e8449;
    white-space: nowrap;
  }
  button:active { transform: translateY(3px); box-shadow: none; }

  /* é€²åº¦æ¢å®¹å™¨ */
  #progress-container {
    position: absolute; 
    top: 10vmin;  
    left: 50%;
    transform: translateX(-50%);
    width: 60%; max-width: 400px;
    height: 30px;
    background: rgba(0,0,0,0.6); 
    border: 2px solid #fff;
    border-radius: 15px;
    overflow: hidden;
    display: none; /* éŠæˆ²é–‹å§‹æ‰é¡¯ç¤º */
    box-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }

  /* é€²åº¦æ¢å¡«å…… */
  #progress-bar {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, #f1c40f, #e67e22);
    transition: width 0.3s ease-out;
  }

  /* é€²åº¦æ–‡å­— */
  #progress-text {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    text-align: center; line-height: 28px;
    color: white; font-weight: bold; font-family: sans-serif;
    text-shadow: 1px 1px 2px black; letter-spacing: 1px;
  }

  /* è½åŠ›æç¤º */
  #listen-hint {
    position: absolute; top: 25%; 
    width: 100%;
    text-align: center; font-size: 15vmin; 
    color: #f1c40f; 
    font-weight: 900; 
    text-shadow: 4px 4px 0px #c0392b; 
    display: none; opacity: 0; transition: opacity 0.3s;
    pointer-events: none;
  }
  #listen-hint.show { display: block; opacity: 1; }

  /* --- é è…³è¨­å®š (Ace English x ç¿Šè¯æ•™è‚²) --- */
  #footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    text-align: center;
    color: white;
    font-size: 4.5vmin; /* æ‰‹æ©Ÿç‰ˆå­—é«”åŠ å¤§ */
    font-weight: bold;  /* åŠ ç²— */
    padding: 1.5vmin;
    background-color: rgba(0, 0, 0, 0.6);
    z-index: 30; 
    letter-spacing: 1px;
    display: flex;             /* ä½¿ç”¨ flex è®“å…§å®¹å±…ä¸­å°é½Š */
    justify-content: center;   /* æ°´å¹³å±…ä¸­ */
    align-items: center;       /* å‚ç›´å±…ä¸­ */
    gap: 8px;                  /* è¨­å®šå…ƒç´ ä¹‹é–“çš„é–“è· */
  }

  /* Ace English é»ƒå­—ç™½æ¡† (ä¿®æ”¹è™•) */
  .ace-style {
      color: #ffd700; /* é‡‘é»ƒè‰² */
      -webkit-text-stroke: 1.2px white; /* CSSæ–‡å­—æé‚Šæ”¹ç‚ºç™½è‰² */
      text-stroke: 1.2px white; 
      font-weight: 900;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.8); /* ä¿ç•™é™°å½±å¢åŠ å°æ¯” */
  }

  /* ç¿Šè¯æ•™è‚² ç¶ å­—ç™½æ¡† (ä¿®æ”¹è™•) */
  .yihua-style {
      color: #2ecc71; /* é®®ç¶ è‰² */
      -webkit-text-stroke: 1.2px white; /* CSSæ–‡å­—æé‚Šæ”¹ç‚ºç™½è‰² */
      text-stroke: 1.2px white;
      font-weight: 900;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.8); /* ä¿ç•™é™°å½±å¢åŠ å°æ¯” */
  }

  .hidden { display: none !important; }

  @media (min-width: 800px) {
    h1 { font-size: 3rem; }
    p { font-size: 1.2rem; }
    button { font-size: 1.8rem; }
    #listen-hint { font-size: 5rem; }
    .victory-text { font-size: 2.5rem; }
    #progress-container { top: 80px; }
    #footer { font-size: 1.5rem; padding: 15px; }
    /* é›»è…¦ç‰ˆæé‚Šä¹Ÿæ”¹ç‚ºç™½è‰² (ä¿®æ”¹è™•) */
    .ace-style, .yihua-style { -webkit-text-stroke: 1.5px white; text-stroke: 1.5px white; }
  }
</style>
</head>
<body>

  <div id="listen-hint">ğŸ”Š Listen!</div>

  <div id="ui-layer">
    
    <div id="progress-container">
      <div id="progress-bar"></div>
      <div id="progress-text">0 / 20</div>
    </div>

    <div id="start-panel" class="center-overlay">
      <h1>ğŸ„ Christmas Saber</h1>
      <p>1. è½è‹±æ–‡å–®å­—<br>2. ç­”å° 20 é¡Œå³å¯é€šé—œ<br>3. æ»‘å‹•æ‰‹æŒ‡åˆ‡é–‹å¡ç‰‡ï¼</p>
      <button onclick="startGame()">Start ğŸ…</button>
    </div>

    <div id="victory-panel" class="center-overlay">
      <h1>ğŸ‰ CONGRATULATIONS! ğŸ‰</h1>
      <div class="victory-text">Bravo!<br>Youâ€™re a Christmas Vocabulary Master.</div>
      <button onclick="location.reload()">Play Again ğŸ”„</button>
    </div>

  </div>

  <div id="footer">
    <span class="ace-style">Ace English</span> x <span class="yihua-style">ç¿Šè¯æ•™è‚²</span>
  </div>

<script>
// --- è³‡æ–™åº« ---
const gameData = [
    { word: "Santa", icon: "ğŸ…", color: "#c0392b" },
    { word: "Tree", icon: "ğŸ„", color: "#27ae60" },
    { word: "Gift", icon: "ğŸ", color: "#f1c40f" },
    { word: "Snowman", icon: "â›„", color: "#3498db" },
    { word: "Star", icon: "â­", color: "#f1c40f" },
    { word: "Bell", icon: "ğŸ””", color: "#e67e22" },
    { word: "Cookie", icon: "ğŸª", color: "#8d6e63" },
    { word: "Candy", icon: "ğŸ¬", color: "#e91e63" },
    { word: "Sock", icon: "ğŸ§¦", color: "#c0392b" },
    { word: "Angel", icon: "ğŸ‘¼", color: "#f39c12" },
    { word: "Reindeer", icon: "ğŸ¦Œ", color: "#8d6e63" },
    { word: "Sleigh", icon: "ğŸ›·", color: "#c0392b" },
    { word: "Elf", icon: "ğŸ§", color: "#27ae60" },
    { word: "Snowflake", icon: "â„ï¸", color: "#a2d9ff" },
    { word: "Candle", icon: "ğŸ•¯ï¸", color: "#f39c12" },
    { word: "Turkey", icon: "ğŸ¦ƒ", color: "#d35400" },
    { word: "Ribbon", icon: "ğŸ€", color: "#e91e63" },
    { word: "Gloves", icon: "ğŸ§¤", color: "#16a085" },
    { word: "Scarf", icon: "ğŸ§£", color: "#e74c3c" },
    { word: "Toy", icon: "ğŸ§¸", color: "#9b59b6" }
];

const phrasesCorrect = ["Awesome!", "Perfect!", "Excellent!", "Great Job!", "Fantastic!", "You Rock!"];
const phrasesWrong = ["Try Again!", "Don't Give Up!", "Keep Going!", "Nice Try!", "Almost There!", "You Can Do It!"];

// --- éŠæˆ²ç‹€æ…‹ ---
let isGameRunning = false;
let correctCount = 0;
const MAX_SCORE = 20;

let cards = [];
let slicedCards = []; // å­˜æ”¾è¢«åˆ‡é–‹çš„ç¢ç‰‡
let particles = [];
let saberTrail = [];
let snowFlakes = []; 
let synth = window.speechSynthesis;
let currentTargetWord = "";
const SPEECH_RATE = 0.85; 

// éŸ¿æ‡‰å¼è®Šæ•¸
let R = {
    cardSize: 0, emojiSize: 0, baseTextSize: 0,
    borderW: 0, feedbackSize: 0, scoreSize: 0,
    leftLaneX: 0, rightLaneX: 0
};

let feedback = { text: "", life: 0, y: 0, scale: 1 };

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  
  calculateResponsiveSizes(); 

  for(let i=0; i<60; i++) {
    snowFlakes.push({
      x: random(width), y: random(height),
      size: random(2, 6), speed: random(0.5, 2.5)
    });
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  calculateResponsiveSizes();
}

function calculateResponsiveSizes() {
    let minDim = min(width, height);
    let isPortrait = width < height;

    if (isPortrait) {
        R.cardSize = constrain(width * 0.2, 60, 130);
    } else {
        R.cardSize = constrain(height * 0.18, 80, 150);
    }

    R.emojiSize = R.cardSize * 0.6;
    R.baseTextSize = R.cardSize * 0.22;
    
    R.borderW = minDim * 0.03;
    R.feedbackSize = minDim * 0.15;
    R.scoreSize = minDim * 0.06;

    R.leftLaneX = width * 0.25;
    R.rightLaneX = width * 0.75;
}

function startGame() {
  document.getElementById('start-panel').classList.add('hidden');
  document.getElementById('progress-container').style.display = 'block'; 
  
  if(synth) synth.speak(new SpeechSynthesisUtterance("")); 
  
  isGameRunning = true;
  correctCount = 0;
  updateProgressUI();
  
  setTimeout(startRound, 800);
}

function updateProgressUI() {
    let pct = (correctCount / MAX_SCORE) * 100;
    document.getElementById('progress-bar').style.width = pct + "%";
    document.getElementById('progress-text').innerText = correctCount + " / " + MAX_SCORE;
}

function startRound() {
  if(!isGameRunning) return;

  let targetData = random(gameData);
  currentTargetWord = targetData.word;
  
  let distractorData;
  do { distractorData = random(gameData); } while(distractorData.word === targetData.word);

  let hint = document.getElementById('listen-hint');
  hint.classList.add('show');
  hint.innerText = "ğŸ”Š Listen...";

  speak(targetData.word, null, SPEECH_RATE);

  setTimeout(() => {
    hint.classList.remove('show');
    spawnCards(targetData, distractorData);
  }, 1000); 
}

function spawnCards(target, distractor) {
  let items = [target, distractor];
  if (random() > 0.5) items.reverse();

  launchCard(R.leftLaneX, height + 50, R.leftLaneX, height * 0.2, items[0], items[0].word === currentTargetWord);
  launchCard(R.rightLaneX, height + 50, R.rightLaneX, height * 0.2, items[1], items[1].word === currentTargetWord);
}

// --- å…±ç”¨ç¹ªåœ–å‡½å¼ ---
function drawCardVisual(size, data, isTarget) {
    fill(255); 
    stroke(isTarget ? "#c0392b" : "#2c3e50"); 
    strokeWeight(3);
    rect(0, 0, size, size * 1.3, 15); // åœ“è§’çŸ©å½¢
    
    textSize(R.emojiSize); noStroke(); 
    text(data.icon, 0, -size*0.15);
    
    let finalFontSize = R.baseTextSize;
    let wordLen = data.word.length;
    if (wordLen > 6) finalFontSize = R.baseTextSize * 0.85;
    if (wordLen > 8) finalFontSize = R.baseTextSize * 0.7;

    fill(0); textSize(finalFontSize); textStyle(BOLD); 
    text(data.word, 0, size*0.4);
}

function launchCard(startX, startY, destX, destY, data, isTarget) {
    let gravity = 0.06; 
    let heightDiff = startY - destY;
    let vy = -Math.sqrt(2 * gravity * heightDiff); 
    let timeToPeak = Math.abs(vy / gravity);
    let vx = (destX - startX) * 0.01; 

    cards.push({
        x: startX, y: startY,
        vx: vx, vy: vy,
        gravity: gravity,
        size: R.cardSize, 
        angle: 0, 
        rotSpeed: random(-0.005, 0.005), 
        data: data, isTarget: isTarget,
        draw: function() {
            push();
            translate(this.x, this.y); rotate(this.angle);
            drawCardVisual(this.size, this.data, this.isTarget);
            pop();
        },
        update: function() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.angle += this.rotSpeed;
        }
    });
}

function draw() {
  setGradient(0, 0, width, height, color(11, 30, 16), color(5, 10, 5));
  drawSnow();
  drawChristmasBorder();

  drawParticles(); 
  updateAndDrawSlicedCards(); // ç¹ªè£½åˆ‡é–‹çš„å¡ç‰‡

  if(!isGameRunning) return;

  // å…‰åŠç‹€æ…‹
  let isSaberActive = false;
  if (touches.length > 0) {
      isSaberActive = true;
      updateSaber(touches[0].x, touches[0].y);
  } else {
      updateSaber(mouseX, mouseY);
      isSaberActive = true; 
  }
  
  if (touches.length === 0 && 'ontouchstart' in window) {
      isSaberActive = false;
      saberTrail = []; 
  }

  let saberSpeed = dist(mouseX, mouseY, pmouseX, pmouseY);
  let isSlashing = saberSpeed > 5; 

  drawSaberOptimized();

  for (let i = cards.length - 1; i >= 0; i--) {
    let c = cards[i];
    if (!c) continue; 
    c.update();
    c.draw();

    if (isSaberActive && isSlashing && dist(mouseX, mouseY, c.x, c.y) < c.size/2 + 20) {
        handleHit(c, i);
        break; 
    } 
    else if (c.y > height + 200) {
      cards.splice(i, 1);
      if(cards.length === 0) setTimeout(startRound, 1000);
    }
  }

  drawFeedback();
}

// --- åˆ‡é–‹ç‰¹æ•ˆé‚è¼¯ ---
function createSliceEffect(card) {
    // ç”¢ç”Ÿå·¦åŠé‚Šç¢ç‰‡ (å‘å·¦é£›)
    slicedCards.push({
        x: card.x, y: card.y,
        vx: card.vx - random(3, 6), 
        vy: card.vy - random(2, 5),
        angle: card.angle, 
        vAngle: -random(0.1, 0.3), // é€†æ™‚é‡æ—‹è½‰
        gravity: 0.3,
        size: card.size,
        data: card.data, isTarget: card.isTarget,
        side: 'left', // æ¨™è¨˜ç‚ºå·¦é‚Š
        life: 255
    });

    // ç”¢ç”Ÿå³åŠé‚Šç¢ç‰‡ (å‘å³é£›)
    slicedCards.push({
        x: card.x, y: card.y,
        vx: card.vx + random(3, 6), 
        vy: card.vy - random(2, 5),
        angle: card.angle, 
        vAngle: random(0.1, 0.3), // é †æ™‚é‡æ—‹è½‰
        gravity: 0.3,
        size: card.size,
        data: card.data, isTarget: card.isTarget,
        side: 'right', // æ¨™è¨˜ç‚ºå³é‚Š
        life: 255
    });
}

function updateAndDrawSlicedCards() {
    for (let i = slicedCards.length - 1; i >= 0; i--) {
        let p = slicedCards[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity;
        p.angle += p.vAngle;
        p.life -= 6; // æ¼¸æ¼¸æ¶ˆå¤±

        if (p.life <= 0) {
            slicedCards.splice(i, 1);
            continue;
        }

        push();
        translate(p.x, p.y);
        rotate(p.angle);
        
        let c = color(255);
        c.setAlpha(p.life);
        
        // ä½¿ç”¨å‰ªè£ (Clipping) æŠ€è¡“
        drawingContext.save();
        drawingContext.beginPath();
        
        let w = p.size;
        let h = p.size * 1.3;
        
        // å®šç¾©å‰ªè£å€åŸŸ (å·¦åŠæˆ–å³åŠ)
        if (p.side === 'left') {
            drawingContext.rect(-w/2, -h/2, w/2, h); 
        } else {
            drawingContext.rect(0, -h/2, w/2, h);
        }
        drawingContext.clip();

        // ç¹ªè£½å®Œæ•´çš„å¡ç‰‡å…§å®¹
        drawCardVisual(p.size, p.data, p.isTarget);
        
        drawingContext.restore();
        pop();
    }
}

// --- å‹åˆ©è™•ç† ---
function triggerVictory() {
    isGameRunning = false;
    cards = []; 
    slicedCards = [];
    document.getElementById('progress-container').style.display = 'none';
    
    const panel = document.getElementById('victory-panel');
    panel.style.display = 'flex';
    
    speak("Bravo! Youâ€™re a Christmas Vocabulary Master.", null, 0.9);
    
    setInterval(() => {
        createExplosion(random(width), random(height), random(['#ff0000', '#00ff00', '#ffd700']));
    }, 300);
}

function handleHit(card, index) {
  // 1. åˆ‡é–‹ç‰¹æ•ˆ
  createSliceEffect(card);
  
  // 2. ç§»é™¤åŸå¡ç‰‡
  cards.splice(index, 1);
  
  // 3. çˆ†ç‚¸ç²’å­
  createExplosion(card.x, card.y, card.data.color);

  if (card.isTarget) {
    correctCount++; 
    updateProgressUI(); 
    
    if (correctCount >= MAX_SCORE) {
        triggerVictory();
        return; 
    }

    triggerFeedback(true);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; setTimeout(startRound, 1200);
  } else {
    triggerFeedback(false);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; setTimeout(startRound, 1200);
  }
}

// --- ç‰¹æ•ˆèˆ‡å·¥å…·å‡½å¼ ---
function createExplosion(x, y, colorHex) {
  for (let i = 0; i < 30; i++) {
    particles.push(new Particle(x, y, colorHex, 'debris'));
  }
  for (let i = 0; i < 20; i++) {
    particles.push(new Particle(x, y, '#ffd700', 'sparkle'));
  }
}

class Particle {
    constructor(x, y, col, type) {
        this.x = x; this.y = y; this.col = col; this.type = type;
        let angle = random(TWO_PI);
        let speed = random(min(width,height)*0.01, min(width,height)*0.03); 
        this.vx = cos(angle) * speed;
        this.vy = sin(angle) * speed;
        this.life = 255;
        this.gravity = 0.4;
        this.friction = 0.94;
        let baseScale = min(width, height) / 800;
        this.size = (type === 'debris' ? random(8, 16) : random(3, 8)) * baseScale;
        this.rot = random(TWO_PI); this.rotSpeed = random(-0.3, 0.3);
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += this.gravity;
        this.vx *= this.friction; this.vy *= this.friction;
        this.life -= this.type === 'debris' ? 5 : 8;
        this.rot += this.rotSpeed; this.size *= 0.96;
    }
    draw() {
        push(); translate(this.x, this.y); rotate(this.rot); noStroke();
        let c = color(this.col); c.setAlpha(this.life); fill(c);
        if (this.type === 'debris') rect(0, 0, this.size, this.size);
        else { blendMode(ADD); circle(0, 0, this.size); blendMode(BLEND); }
        pop();
    }
}

function drawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update(); p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function triggerFeedback(isCorrect) {
    feedback.text = isCorrect ? random(phrasesCorrect) : random(phrasesWrong);
    feedback.life = 255; feedback.y = height / 2; feedback.scale = 0.5;
}

function drawFeedback() {
    if (feedback.life > 0) {
        push();
        translate(width / 2, feedback.y);
        scale(feedback.scale);
        let goldColor = color(255, 215, 0, feedback.life);
        drawingContext.shadowBlur = 40; drawingContext.shadowColor = 'rgba(255, 215, 0, 0.8)';
        fill(goldColor); stroke(255, feedback.life); strokeWeight(3);
        textSize(R.feedbackSize); 
        textStyle(BOLD); text(feedback.text, 0, 0);
        feedback.life -= 4; feedback.y -= 1.5;
        if(feedback.scale < 1.2) feedback.scale += 0.05;
        drawingContext.shadowBlur = 0;
        pop();
    }
}

function drawChristmasBorder() {
  push(); rectMode(CORNER); noStroke();
  let borderW = R.borderW; 
  let stripeLen = borderW * 1.5; 
  let redC = color('#c0392b'); let greenC = color('#27ae60');

  for(let x = 0; x < width; x += stripeLen) {
    fill((x / stripeLen) % 2 === 0 ? redC : greenC); rect(x, 0, stripeLen, borderW);
    fill((x / stripeLen) % 2 !== 0 ? redC : greenC); rect(x, height - borderW, stripeLen, borderW);
  }
  for(let y = borderW; y < height - borderW; y += stripeLen) {
    fill((y / stripeLen) % 2 === 0 ? redC : greenC); rect(0, y, borderW, stripeLen);
    fill((y / stripeLen) % 2 !== 0 ? redC : greenC); rect(width - borderW, y, borderW, stripeLen);
  }
  
  fill(redC); rect(0,0,borderW,borderW);
  fill(greenC); rect(width-borderW,0,borderW,borderW);
  fill(greenC); rect(0,height-borderW,borderW,borderW);
  fill(redC); rect(width-borderW,height-borderW,borderW,borderW);
  pop();
}

function updateSaber(x, y) {
  saberTrail.push({x: x, y: y, life: 8});
  for (let i = saberTrail.length - 1; i >= 0; i--) {
    saberTrail[i].life--;
    if (saberTrail[i].life <= 0) saberTrail.splice(i, 1);
  }
}

function drawSaberOptimized() {
  if (saberTrail.length < 2) return;
  blendMode(ADD); 
  noFill(); strokeCap(ROUND); strokeJoin(ROUND);
  stroke(255, 0, 0, 100); strokeWeight(25);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  stroke(255, 50, 50, 200); strokeWeight(15);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  stroke(255, 255, 255, 255); strokeWeight(5);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  blendMode(BLEND); 
}

function drawSnow() {
  fill(255, 100); noStroke();
  for(let s of snowFlakes) {
    circle(s.x, s.y, s.size);
    s.y += s.speed;
    if(s.y > height) s.y = -10;
  }
}

function setGradient(x, y, w, h, c1, c2) {
  noFill();
  for (let i = y; i <= y + h; i+=10) { 
    let inter = map(i, y, y + h, 0, 1);
    let c = lerpColor(c1, c2, inter);
    stroke(c); strokeWeight(10);
    line(x, i, x + w, i);
  }
}

function speak(text, callback, rate = 1.0) {
  synth.cancel();
  let u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US'; u.rate = rate; 
  if(callback) u.onend = callback;
  synth.speak(u);
}
</script>
</body>
</html>
